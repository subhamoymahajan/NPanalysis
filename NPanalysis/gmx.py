# This Program is used to analyze properties of two-component nanoparticle. It 
# is primarily designed to assist Gromacs analysis 
#    Copyright (C) 2021 Subhamoy Mahajan <subhamoygithub@gmail.com>
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <https://www.gnu.org/licenses/>.
#
# The codes used in this software have been used in publications. If you find 
# this useful, please cite:
#
# (1) Subhamoy Mahajan and Tian Tang, "Polyethylenimine-DNA Ratio Strongly 
#     Affects Their Nanoparticle Formation: A Large-Scale Coarse-Grained 
#     Molecular Dynamics Study", 2019, J. Phys. Chem. B, 123 (45), 9629-9640, 
#     DOI: https://doi.org/10.1021/acs.jpcb.9b07031
#
import os
import networkx as nx
import numpy as np
from . import geometry

def pickle_mindist(fileheader='mindist', mindist_pickle='mindist.pickle', \
    time_pickle='time.pickle', time_fac=1, time_shift=0):
    """Pickle the mindist data generated by Gromacs and time.
    
    Parameters
    ----------
    fileheader: str, optional
        Filenames [fileheader][i]-[j].xvg will be read, which contains the 
        minimum distance between DNA [i] and PEI [j].
    mindist_pickle: str, optional
        Filename to save the pickled minimum distance data. 
        (default value is 'mindist.pickle')
    time_pickle: str, optional
        Filename to save the pickled simulation time. 
        (default value is 'time.pickle')
    time_fac: float, optional
        Multiply the simulation time by a factor. (default valus is 1)
    time_shift: float, optional
        Shift the simulation time by a constant. (default value is 0)
    Writes
    ------
    [mindist_pickle]: pickled data of a 3D numpy array of floats.
        For details see connMat.gro2connected()
    [time_pickle]: pickled data of a numpy array of floats.
        For details see connMat.gro2connected()
    """
    constants=nx.read_gpickle('constants.pickle')
    ndna=constants['ndna']
    npei=constants['npei']
    contact_dist=constants['contact_dist']
    #Determine number of timesteps from mindist file.
    f=open(fileheader+'0-0.xvg')
    sim_time=[]
    times=0
    for lines in f:
        if lines[0]=="@" or lines[0]=="#":
            continue
        foo=lines.split()
        sim_time.append(float(foo[0]))
        times+=1
    sim_time=np.array(sim_time)
    sim_time=sim_time*time_fac+time_shift

    mindists=np.zeros((times,ndna,npei))
    print("\nReading: "+fileheader+"*.xvg")
    for d in range(ndna):
        for p in range(npei):
    	#Read all the mindist files which contains the minimum distance of each pair of DNA-PEIs at different time
            f=open(fileheader+str(d)+"-"+str(p)+".xvg","r")
            t=0
            for lines in f:
                foo=lines.split()
                if foo[0][0]=='#' or foo[0][0]=='@':
                    continue
                if t==times:
                    raise Exception("Total number of timesteps not same for all mindist files")
                mindists[t,d,p]=float(foo[1])
                t+=1 
            if t!=times:
                raise Exception("Total number of timesteps not same for all mindist files")
            f.close()       
    print("Writing: "+mindist_pickle+" "+time_pickle) 
    nx.write_gpickle(mindists,mindist_pickle)
    nx.write_gpickle(sim_time,time_pickle)

def pickle_mass(filename='tprdump',mass_pickle='mass.pickle'):
    """Reads mass data file and pickles it.

    Parameters
    ----------
    filename: str, optional
        Filename containing the output of 'gmx dump -s file.tpr'. 
        (default is 'trpdump')
    mass_pickle: str, optional
        Filename of the output pickle file. (default is 'mass.pickle')
      
    Writes
    ------
    [mass_pickle]: pickled file of list.
        Contains a list of atom mass, ordered according to the global ID of 
        atoms. 
    """
    print("Writing: "+str(mass_pickle))
    mass=[]
    f=open(filename,"r")
    #######################################################
    #Location of mass information in gmx dump
    #  |topology:
    #  |   moltype (0):
    #  |      atoms:
    #  |         atom ([Number of atoms]):
    #  |              [Mass information] along with other information
    #  |         atom ([Number of atoms]):
    #
    # A typical line containing mass information: (\ is artificial line break)
    # "atom[  2484]={type=  1, typeB=  1, ptype=    Atom," \
    #  " m= 4.50000e+01, q= 0.00000e+00, mB= 4.50000e+01,"\
    #  " qB= 0.00000e+00, resind=  387, atomnumber=  0}]
    #######################################################
    # State:
    #   0: Not reading mass information
    #   1: Reading mass information
    #   2: Stop reading file 
    state=0  
    for lines in f:
        if lines[9:15]=="atom (":
            state+=1
            if state>1:
                break
            foo=lines[15:].split(')')
            N=int(foo[0])
        elif state==1:
            #Isolate the string between 'm=' and ','
            foo=lines.split('m=')
            foo=foo[1].split(',')
            # Convert the string to float and append to mass
            mass.append(float(foo[0]))
            
    if N!=len(mass):
        raise Exception('Number of atoms from gmx dump not equal to mass')
    mass=np.array(mass)
    nx.write_gpickle(mass,mass_pickle)

def read_gro(filename): 
    """Reads a Gromacs structure file

    Parameters
    ----------
    filename: str
        Name of the Gromacs structure file.

    Returns
    -------
    pos: 2D numpy ndarray of floats
        Position of atoms. Axis 0 is the global atom ID, and axis 1 is the
        direction.
    box: 1D numpy array of floats
        box[r] stores the cuboidal box dimensions. r = 0, 1, 2, for x, y, and z
        axis respectively.
    text: 1D array for strings
        contains verbatimm lines of the Gro file. In lines containing position 
        of particles only text before it is saved.
    """
    f=open(filename,'r')
    texts=[]
    cnt=0
    #texts reads all lines verbatim except for lines containing position.
    for lines in f:
        if cnt==0:
            texts.append(lines)
        elif cnt==1:
            texts.append(lines)
            foo=lines.split()
            N=int(foo[0]) #Number of atoms in the gro file
            pos=np.zeros((N,3))
        elif cnt>1 and cnt<N+2:#atoms
            texts.append(lines[:20]) # For lines containing positions only 
                                     # information before position is stored.
            pos[cnt-2][0]=float(lines[20:28])
            pos[cnt-2][1]=float(lines[28:36])
            pos[cnt-2][2]=float(lines[36:44])
        else:
            texts.append(lines)
            foo=lines.split()
            if len(foo)!=3: #Not supported
                raise Exception("Code only supported for cubiodal boxes")
            else:
                box=[float(foo[0]),float(foo[1]),float(foo[2])]
                box=np.array(box)
        cnt+=1
    f.close()
    return pos,box,texts

def write_gro(filename,pos,texts):
    """Writes the Gromacs structure file for a given position, and other 
       text information

    Parameters
    ----------
    filename: str
        Output file name. Must end with .gro
    pos: 2D numpy array of floats
        Position of atoms. Axis 0 is the global atom ID, and axis 1 is the
        direction.
    texts: numpy array of strings   
        Contains all text information of a .gro file, except the position 
        coordinates.     
   
    Writes
    ------
    [outname][t].gro: Gromacs structure file
        Writes file in the Gromacs .gro format. [t] is the timestep. 
    """
    if filename[-4:]!='.gro':
        raise Exception(filename+' is not a .gro file!')
    os.makedirs(os.path.dirname(filename), exist_ok=True)
    w=open(filename,'w')
    cnt=0
    for i in range(len(texts)):
        w.write(texts[i])
        if cnt>1 and cnt<2+len(pos):
            for x in range(3):
                a="{:.3f}".format(pos[cnt-2][x])
                w.write(a.rjust(8))
            w.write('\n')
        cnt+=1
    w.close()

def get_NPatomIDs(clusters, ndx, dna_name, pei_name, main_mol): 
    """Calculates the global IDs of atoms from a list of DNAs and PEIs molecule IDs.
    
    Parameters
    ----------
    cluster: 2D array of integers
       Contains all atom IDs in each cluster. Axis 0 is the cluster ID. Each
       cluster ID returns a list of DNA and PEI molecule IDs. If molecule ID
       of DNA is -1 imples the PEIs are free PEIs. Similarly if molecule ID of 
       PEI is -1 implies the DNAs are free DNAs.       
    ndx: dictionary
       Dictionary containing atom IDs for each molecule. The key is the molecule
       name with ID ("[Molecule Name][ID]"). The value is a list of global ID of 
       atoms in the molecule. 
    dna_name: str
       name of DNA molecules in the ndx file
    pei_name: str
       name of PEI molecules in the ndx file
    main_mol: int, optional
        Chooses a main molecule to calculate size of nanoparticle. 0 represents
        DNA and 1 represents PEI. (default value is 0).

    Returns
    -------
    atoms: array of integers
       List of global IDs of atom 
    """
    atoms=[]
    for i in range(len(clusters)-2):
        atoms_c=[]
        for d in clusters[i][0]:
            atoms_c+=ndx[dna_name+str(d)]
        for p in clusters[i][1]:
            atoms_c+=ndx[pei_name+str(p)]
        atoms.append(np.array(atoms_c))
    if main_mol==0: #dna
        for d in clusters[-2][0]:
            atoms.append(np.array(ndx[dna_name+str(d)])) 
    if main_mol==1: #pei
        for p in clusters[-1][1]:
            atoms.append(np.array(ndx[pei_name+str(p)])) 
    return atoms

def make_NPwhole(inGRO='DP',outGRO='New', cluster_pickle='cluster.pickle', \
    connected_pickle='connected.pickle', ndx_pickle='molndx.pickle'):
    """Updates .gro files to make nanoparticles whole, for a tim
  
    Parameters
    ----------
    inGRO: str, optional
        The starting strings of input Gromacs structure files. For details see
        connMat.gro2connected(). (default value is 'DP')
    outGRO: str, optional
        Output Gromacs structure files. (defaut valus is 'New')  
    cluster_pickle: str, optional
        Filename which contains pickled cluster data. See cluster.gen_cluster()
        for more details. (default value is 'cluster.pickle')
    connected_pickle: str, optional
        Filename which contains pickled connection matrix data. For detrails see
        connMat.gro2connected(). (default value is 'connected.pickle')
    ndx_pickle: str, optional
        Filename of the pickled Gromacs index file. See gmx.gen_index_mol() for
        more details. (default value is 'molndx.pickle') 

    Writes
    ------
    [outname][t].gro: Gromacs .gro file format
        Writes file in the Gromacs .gro format. [t] is the timestep. 
        Nanoparticles are made whole.  
    """
    constants=nx.read_gpickle('constants.pickle')
    dna_name=constants['dna_name']
    pei_name=constants['pei_name']
    DP_name=[dna_name, pei_name]
    contact_dist=constants['contact_dist']
    pbc=np.array(constants['pbc'])

    clusters=nx.read_gpickle(cluster_pickle)
    connected=nx.read_gpickle(connected_pickle)
    ndx=nx.read_gpickle(ndx_pickle)
    times=len(connected)

    for t in range(times): # Iterate over all simulation time
        pos,box,texts=read_gro(inGRO+str(t)+'.gro')
        # using main_mol = 0 but its inconsequential.
        atoms=get_NPatomIDs(clusters[t],ndx,dna_name,pei_name,0) 
        for cid in range(len(clusters[t])-2): 
        # Don't iterate over free molecules as they are already whole.
            finished=[] # Contains all DNAs and PEIs in the NP that have been
                        # moved to the right location by applying PBC
            queued=[] #for determining next DNA or PEI to be moved.
            queued.append(dna_name+str(clusters[t][cid][0][0])) 
            #Adds the first DNA in the NP to the queue
            # Algorithm:
            #   Starting from the first DNA molecule in the cluster. All PEIs
            #   bound to it is moved closer to the first DNA molecule. Then all
            #   DNAs bound to PEIs are moved closter to the PEIs if they were
            #   not already moved. This sequential moving of molecules avoids
            #   moving a molecule twice. Then the center of the entire 
            #   nanoparticle is moved such that the center is within the simulation
            #   box. 
            while len(queued)>0:
                #name: name of current molecule 
                # atoms1: Global ID of all atoms in current molecule
                name=queued.pop(0) 
                atoms1=np.array(ndx[name])
                # id1: molecule ID of the current moelcule 
                # nexts: molecules bound to the current molecule
                # next_names: name of molecules bound to current molecule
                if name[:len(dna_name)]==dna_name: #current molecule is a dna
                    id1=int(name[len(dna_name):]) #id = DNA ID
                    # nexts has molecule IDs of all PEIs bound to DNA [id],
                    # and next_names has all the names
                    nexts=np.where(connected[t,id1,:]==True)[0]
                    next_names=[pei_name+str(x) for x in nexts] 
                    next_name=pei_name
                elif name[:len(pei_name)]==pei_name:# current molecule is a pei
                    id1=int(name[len(pei_name):]) # id = PEI ID
                    # nexts has molecule IDs of all DNAs bound to PEI [id], 
                    # and next_names has all the names
                    nexts=np.where(connected[t,:,id1]==True)[0] 
                    next_names=[dna_name+str(x) for x in nexts] 
                    next_name=dna_name
                for nam in next_names: #for each bound molecule name
                    if nam in finished: # Do not move moved molecules again.
                        continue
                    atoms2=np.array(ndx[nam]) #get atoms in the bound molecule
                    # find the disp required for atom2 to reduce minimum 
                    # distance between atoms2 and atoms12
                    disp=geometry.get_pbcdisp_mols(pos,box,atoms1,atoms2,pbc)
                    pos=geometry.change_pos(pos,disp,atoms2)  
                # add the name of current molecule in finished since all bound 
                # molecules to the current molecule are moved
                finished.append(name) 
                for nam in next_names: # for each bound molecule
                    # if they are not queued and not finished queue them.
                    if nam not in queued: 
                        if nam not in finished:
                            queued.append(nam)
            #atoms: Global ID of all atoms in the cluster
            #move the geometric center NP to within the primary simulation box. 
            pos=geometry.change_NPpos(pos,box,atoms[cid],pbc) 
        print('Writing: '+outGRO+str(t)+'.gro     ',end="\r")
        write_gro(outGRO+str(t)+'.gro',pos,texts)
    print("\n")
       
def gen_index_mol(ndx_pickle='molndx.pickle'):
    """Calculates global atom IDs of atoms present in each DNA and PEI molecule.
       
    Assumes the index of DNAs start from [snda], having [ndna] DNA molecules, 
    each with [adna] atoms. Similarly, index of PEIs start from [spei], having 
    [npei] PEI molecules, each with [apei] atoms.

    out_pickle: str, optional
        Filename of the output pickled file. (default value is 'molndx.pickle')

    Writes
    ------
    [ndx_pickle]: pickled dictionary.
        Contains a dictionary with molecule name along with their IDs 
        ("[Molecule Name][ID]") as keys and the value is a list of global IDs 
        of atoms in the molecule. 
    """
    print("Writing: molndx.pickle")
    constants=nx.read_gpickle('constants.pickle')
    ndna=constants['ndna']
    adna=constants['adna']
    sdna=constants['sdna']
    dna_name=constants['dna_name']
    npei=constants['npei']
    apei=constants['apei']
    spei=constants['spei']
    pei_name=constants['pei_name'] 

    ndx={}
    for d in range(ndna):
        ndx[dna_name+str(d)]=[]
        for di in range(adna):
            # Saved in python format, should be increased by 1 for Gromacs use.
            ndx[dna_name+str(d)].append(d*adna+sdna+di-1) 
    
    for p in range(npei):
        ndx[pei_name+str(p)]=[]
        for pi in range(apei):
            # Saved in python format, should be increased by 1 for Gromacs use.
            ndx[pei_name+str(p)].append(p*apei+spei+pi-1) 
    
    nx.write_gpickle(ndx,'molndx.pickle')


def write_index_mol(outname,ndx_pickle='molndx.pickle'):
    """Writes a Gromacs index file (“.ndx”) for each DNA and PEI molecules.

    It Assumes first 'ndna' molecules are DNAs followed by 'npei' PEIs. Each 
    DNA consists of 'adna' atoms and each PEI consists of 'apei' atoms.

    Parameters
    ----------
    outname: str
         Output filename. Should end with '.ndx'.
    ndx_pickle: str, optional
        Filename of the pickled Gromacs index file. For details see 
        gmx.gen_index_mol(). (default value is 'molndx.pickle')

    Writes
    ------
    [outname]: Gromacs .ndx file format
         Contains atom IDs for each DNA and PEI molecule in separate groups.
    """
    if outname[-4:]!='.ndx':
        raise Exception('Index file should end with .ndx')
    print("Writing: "+outname)
    constants=nx.read_gpickle('constants.pickle')
    pei_name=constants['pei_name']
    dna_name=constants['dna_name']
    ndna=constants['ndna']
    npei=constants['npei']
    adna=constants['adna']
    apei=constants['apei']

    w=open(outname,"w")
    ndx=nx.read_gpickle(ndx_pickle)
    for i in range(ndna):
        w.write("[ "+dna_name+str(i)+" ]\n")
        for j in range(adna):
            w.write(str(ndx[dna_name+str(i)][j]+1)+' ')
            if (j+1)%20==0:
                w.write('\n') 
        w.write('\n') 
    for i in range(npei):
        w.write("[ "+pei_name+str(i)+" ]\n")
        for j in range(apei):
            w.write(str(ndx[pei_name+str(i)][j]+1)+' ')
            if (j+1)%20==0:
                w.write('\n') 
        w.write('\n') 
    w.write("\n")
    w.close()

def read_ndx(filename,ndx_pickle='molndx.pickle'):
    """Reads a index file and pickles it.

    Looks for groups with the name 'dna_name' and 'pei_name' mentioned in the 
    constants file.

    Parameters
    ----------
    filename: str
        Name of the index file
    out_pickle: str, optional
        Filename of the output pickled file. (default value is 'molndx.pickle')

    Writes
    ------
    [out_pickle]: pickled dictionary.
        For details see gmx.gen_index_mol()
    """
    state=0 # 0 = reading molecule name, 1= reading atom ids.
    constants=nx.read_gpickle('constants.pickle')
    dna_name=constants['dna_name']
    pei_name=constants['pei_name']
    ndx={} 
    f=open(filename,'r')
    for lines in f:
        if len(lines)==0:
            continue
        
        if '[' in lines: # group name header.
            name=lines.strip() # removes newline
            name=name.strip('[] ') # removes [, ], and space.
            if name[:len(dna_name)]==dna_name: #Is a dna
                state=1
                ndx[name]=[]
                if not name[len(dna_name)].isnumeric(): 
                    raise Exception("Name in constants file ("+str(dna_name)+ \
                        ") does not match with molecule name "+str(name))
            elif name[:len(pei_name)]==pei_name: #Is a pei
                state=1
                ndx[name]=[]
                if not name[len(dna_name)].isnumeric(): 
                    raise Exception("Name in constants file ("+str(dna_name)+ \
                          ") does not match with molecule name "+str(name))
            continue
        elif state==1: # read atom IDs
            foo=lines.split()
            foo=[int(x)-1 for x in foo]
            ndx[name]+=foo

    print("Writing: "+out_pickle)
    nx.write_gpickle(ndx,out_pickle)
